# BenchmarkSQL

BenchmarkSQL is a [GPLv2](docs/LICENSE.txt) fair-use TPC-C like testing
tool.

## Start

1. Open `docs/HOW-TO-RUN-Postgres.txt` to check how to create the database and user.  

2. Check if Maven is installed by running: ```mvn --version```
If the command returns nothing, install Maven.
On macOS, you can do this with: ```brew install maven```

3. Then just ```nvm``` and will be created a new dir `/target`. Make sure that the `my.properties` file was proper copied into the new directory.

Note: For read-only tests, the my.properties should have the following values:
```bash
paymentWeight=0.0
orderStatusWeight=0.0
deliveryWeight=0.0
stockLevelWeight=100.0 # as this is the only read-only transation
```

4. Go to the ```target/run``` directory and then you can build, destroy the database and run the benchmark.

To Build: ```./runDatabaseBuild.sh my.properties```

To Run: ```./runBenchark.sh my.properties```

To Destroy: ```./runDatabaseDestroy.sh my.properties```

## Report Generation

Follow the steps below to set up the environment and generate the HTML report.

1. Create and Activate a Virtual Environment, with: 
    ```bash 
    python3 -m venv env
    source env/bin/activate
    ```

2. Install R
    ```bash
    brew install r
    R --version # to check
    ```

3. Install the required Python packages:
    ```bash
    pip install numpy matplotlib jinja2
    ```

4. Run the following command, replacing "RESULT_DIR" with the path to the directory generated by your run:
    ```bash
    python3 generateReport.py --resultdir="RESULT_DIR" 
    ```

5. After running the script, an HTML file containing the report will be generated.

## Overview

BenchmarkSQL is implemented in Java, using JDBC to stress test SQL databases.
The overall architecture is a series of data structures, queues and thread
groups that handle the simulated terminals, users and application threads. 

Its architecture allows BenchmarkSQL to drive TPC-C configurations up to many
thousands of warehouses (known as the scaling factor) without overwhelming the
job scheduler of the test driver itself.
Yet it is capable of doing so without sacrificing one of the most important
measurements in a TPC-C, the end-user experienced response time at the terminal.

![TimedDriver](docs/TimedDriver-1.svg)

Please read the [Full Architecture Description](docs/TimedDriver.md)
for a detailed explanation of the above diagram.

## Documentation

For more information, you can visit	the
[Standard specification from TPC](http://tpc.org/tpc_documents_current_versions/pdf/tpc-c_v5.11.0.pdf).

